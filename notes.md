# CMSIS
Есть удобные макросы `SET_BIT`, `READ_BIT`, `CLEAR_BIT`, `SET_REG`, `READ_REG`, `CLEAR_BIT`.
`MODIFY_REG(REG, CLEARMASK, SETMASK)` сбрасывает биты, по маске CLEARMASK, в регистре REG, а потом устанавливает биты в соответствии SETMASK. Определение макроса:
```
#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
```

ВАЖНО: все регистры и битовые поля актальны для f103. Но думаю принцип везде одинаковый
## Тактирование
Все надо тактировать. В том число и `AFIO`
### RCC (99 страница даташита)
В регистре `CR` включается HSI, HSE, PLL, CSS (Clock security switch system) и там же можно посмотреть их статус. 
Также тут есть бит HSITRIM, которым можно немного откорректировать точность HSI. Для включения какого либо источника
тактирования, используется бит `RCC_CR_*ON`, для проверки `RCC_CR_*RDY`, но этот бит выставляется не сразу, а спустя пару
тиков (если верить даташиту)

В регистре `CFGR` можно настроить умножители и делители разных шин и PLL. Проверить что используется для тактирования SWS (System clock switch status, RO).

Ну и в общем, для того чтобы настроить тактирование (от HSE) надо:
- Включить HSE (дождать флага RDY)
- Настроить память FLASH
- Назначить делители HPRE, PPRE1, PPRE2
- Назначить множитель для PLL.
- Назначить входом для PLL HSE
- Назначить источником системного тактирования (SW) PLL (потом проверить в SWS от чего тактируемся)

Для HSI тоже самое только надо отключить тактирование от HSE и HSEBPY

## SysTick
Таймера считает от значения `STK_LOAD` до нуля. `STK_CALIB` -- калибровочный, RO. `STK_VAL` текущее значение таймера.
`STK_CTRL` COUNTFLAG -- 1, когда таймера досчитал, CLKSOURCE выбор источника тактирования (AHB или AHB/8), TICKINT разрешение на прерывание.

Надо:
- Загрузить значение от которого будем считать в `STK_LOAD` (помнить что там 24 бита, а еще можно сбросить регистр, не задев лишние биты, чтобы быть уверенным, что там будет лежать нужное значение)
- Сбросить значение `STK_VAL` чтобы быть уверенным, что считаем заново
- Выбрать источник тактирования для SysTick

## TIM2

- Затактировать таймер
- Включить прервывание (глобальное), с помощью `NVIC_EnableIRQ()`
- Выставить делитель
- Выставить число до (от) которого будем считать
- Еще надо включить прерывание по обновлению таймера `TIM2_DIER->UIE`
- Еще не забыть включить счетчик `TIM2_CR1->CEN`

А еще есть `TIMx_CR->UIF` бит, который поднимается при прерывании (три случая, смотри даташит)
